///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// External Dependencies Section: Header Files and Namespaces 
#include<iostream>
using namespace std;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Structure of SinglyLL and SinglyCLL 
template<class T>
struct NodeS
{
    T data ; 
    struct NodeS* next;
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Structure of Doubly Linear and Doubly Circular Linked List 
template<class T>
struct NodeD
{
    T data ; 
    struct NodeD *prev ; 
    struct NodeD *next ; 
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Structure of Stack 
template<class T>
struct Node 
{
    T data ; 
    struct Node *next;
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Structure of Queue
template <class T>
struct nodeq
{
    T data ; 
    struct nodeq<T> *next ; 
}; 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Typedef Section of Singly Linked List 
template<class T>
using NODES = NodeS<T> ;

template<class T>
using PNODES = NodeS<T> * ; 

template<class T>
using PPNODES = NodeS<T> ** ; 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// typedef section of Doubly Linked List 
template<class T>
using NODED = NodeD<T>;

template<class T>
using PNODED = NodeD<T> *;

template<class T>
using PPNODED = NodeD<T> ** ; 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Typedef Section of Stack 
template<class T>
using NODE = Node<T> ;

template<class T>
using PNODE = Node<T> * ; 

template<class T>
using PPNODE = Node<T> ** ; 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// typedef Section of Queue 
template<class T>
using NODEQ = nodeq<T> ;

template<class T>
using PNODEQ = nodeq<T> * ; 

template<class T>
using PPNODEQ = nodeq<T> ** ; 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class Declaration of Singly Linear Linked List 
template<class T>
class SinglyLL
{
    public : 
        int iNodeCnt ; 
        PNODES<T> First ; 

        SinglyLL();
        ~SinglyLL();

        void InsertFirst(T iNo);
        void InsertLast(T iNo);
        void InsertAtPos(T iNo,int iPos);

        void DeleteFirst();
        void DeleteLast();
        void DeleteAtPos(int iPos);

        void Reverse();
        int SearchFirstOccurrence(T No);
        int SearchLastOccurrence(T No);

        void Display();
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class Declaration of Singly Circular Linked List 
template<class T>
class SinglyCL 
{
    public : 
        PNODES<T> First ; 
        PNODES<T> Last ; 
        int iNodeCnt ; 

        SinglyCL() ; 
        ~SinglyCL();

        void InsertFirst(T iNo) ; 
        void InsertLast(T iNo) ; 
        void InsertAtPos(T iNo,int iPos) ; 

        void DeleteFirst() ; 
        void DeleteLast() ; 
        void DeleteAtPos(int iPos) ; 

        void Display() ; 
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class Declaration of Doubly Linear Linked List
template<class T>
class DoublyLL
{
    public : 
        PNODED<T> First ;
        int iNodeCnt ; 

        DoublyLL();
        ~DoublyLL();

        void InsertFirst(T iNo); 
        void InsertLast(T iNo );
        void InsertAtPos(T iNo , int iPos ); 

        void DeleteFirst();
        void DeleteLast();
        void DeleteAtPos(int iPos);

        void Display();
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class Declaration of Doubly Circular Linked List 
template<class T>
class DoublyCL
{
    public : 
        PNODED<T> First ; 
        PNODED<T> Last ; 
        int iNodeCnt ; 

        DoublyCL();
        ~DoublyCL();

        void InsertFirst(T iNo) ; 
        void InsertLast(T iNo) ; 
        void InsertAtPos(T iNo,int iPos) ; 

        void DeleteFirst();
        void DeleteLast();
        void DeleteAtPos(int iPos );

        void Display();
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class Declaration of Stack 
template<class T>
class Stack
{
    public : 
        PNODE<T> First;
        int iNodeCnt ;

        Stack(); 

        bool isStackEmpty();
        void push(T iNo); // InsertFirst 
        T pop();//DeleteFirst
        void Display();
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class Declaration of Queue 
template <class T>
class Queue
{
    public : 
        PNODEQ<T> First ; 
        int iCount ; 

        Queue<T>() ; 

        bool IsQueueEmpty() ; 
        void EnQueue(T no) ; /// Insert
        T DeQueue() ; // Delete 
        void Display() ; 
}; 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method Definations of Singly Linear Linked List 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : SinglyLL(Constructor) 
// Description : To Initialize the Characteristics as well as allocate the Resources of Singly Linear Linked List class 
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 28 - November - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
SinglyLL<T>::SinglyLL() 
{
    First = NULL;
    iNodeCnt = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : ~SinglyLL(Destructor) 
// Description : To Deallocate the Resources that are attached with the Linked List 
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 28 - November - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
SinglyLL<T>::~SinglyLL() 
{
    delete First ; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertFirst 
// Description : To Insert the an Element at Beginning of the Linked List
// Input : Element that you want to insert
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 28 - November - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyLL<T>::InsertFirst(T iNo)
{
    PNODES<T> newn = new NODES<T> ; 
    newn->data = iNo;
    newn->next = NULL;

    if(First == NULL )// LL is empty 
    {
        First = newn ; 
        iNodeCnt++;
    }
    else 
    {
        newn->next = First ; 
        First = newn ; 
        iNodeCnt++;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertLast 
// Description : To Insert the an Element at the end of the Linked List
// Input : Element that you want to insert
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 28 - November - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyLL<T>::InsertLast(T iNo)
{
    PNODES <T>newn  = new NODES<T> ; 
    newn->data = iNo;
    newn->next = NULL ; 

    if(First == NULL)
    {
        First = newn ; 
        iNodeCnt++;
    }
    else 
    {
        PNODES <T>temp = First ; 
        while(temp ->next != NULL )
        {
            temp = temp -> next ; 
        }
        temp->next = newn;
        iNodeCnt++;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertAtPos 
// Description : To Insert the an Element at the specified Position 
// Input : Element that you want to insert and the position at which you want to Insert the Node/ Element
// Output : NULL
// Author : Arvind Motiram Kale 
// Date : 28 - November - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyLL<T>::InsertAtPos(T iNo,int iPos)
{
    PNODES <T>newn = new NODES<T>; 
    newn->data = iNo;
    newn->next = NULL;

    if(iPos < 1 || iPos > iNodeCnt + 1 )
    {
        cout<<"Invalid Position\n";
        return ;
    }

    if(iPos == 1)
    {
        InsertFirst(iNo);
    }
    else if(iPos == iNodeCnt + 1 )
    {
        InsertLast(iNo);
    }
    else 
    {
        PNODES <T>Temp = First ; 

        for(int iCnt = 1 ; iCnt < iPos - 1; iCnt++ )
        {
            Temp = Temp -> next ; 
        }

        newn -> next = Temp -> next ; 
        Temp -> next = newn ; 
        iNodeCnt++;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : Display 
// Description : To Display the elements of Linked List 
// Input : NULL
// Output : NULL
// Author : Arvind Motiram Kale 
// Date : 28 - November - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyLL<T>::Display()
{
    cout<<"Elements of Singly Linear Linked List are : \n";
    PNODES<T> Temp = First;

    while(Temp != NULL)
    {
        cout<<"| "<<Temp->data<<"|->" ; 
        Temp = Temp -> next ;
    }

    cout<<"NULL\n";
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteFirst 
// Description : To Delete/Remove the First element of Linked List 
// Input : NULL
// Output : NULL
// Author : Arvind Motiram Kale 
// Date :  3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyLL<T>::DeleteFirst()
{
    if(First == NULL)//Linked List is Empty
    {
        return;
    }
    else if(First->next==NULL)
    {
        delete First;
        First = NULL ; 
        iNodeCnt--;
    }
    else 
    {
        PNODES <T>temp = First ; 
        First = First -> next ; 
        delete temp ; 
        iNodeCnt--;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteLast 
// Description : To Delete/Remove the Last element of Linked List 
// Input : NULL
// Output : NULL
// Author : Arvind Motiram Kale 
// Date :  3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyLL<T>::DeleteLast()
{
    if(First == NULL )
    {
        return ;
    }
    else if(First->next == NULL ) // At least one Node 
    {
        delete First ; 
        First = NULL ; 
    }
    else 
    {
        PNODES<T> temp = First;

        while(temp->next->next != NULL)
        {
            temp = temp -> next ; 
        }

        delete temp->next;
        temp->next = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteAtPos 
// Description : To Delete/Remove the element at specified Position of Linked List 
// Input : Position of such Elemnet that you want to Remove(Integer)
// Output : NULL
// Author : Arvind Motiram Kale 
// Date :  3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyLL<T>::DeleteAtPos(int iPos)
{
    if( iPos < 1 || iPos > iNodeCnt ) 
    {
        cout<<"Invalid Position\n";
        return ; 
    }
    if(iPos ==1 )
    {
        DeleteFirst();
    }
    else if(iPos == iNodeCnt)
    {
        DeleteLast();
    }
    else
    {
        PNODES <T>temp1 = First ; 
        PNODES <T>temp2 = NULL;
        for(int iCnt = 1 ; iCnt < iPos -1 ; iCnt++ )
        {
            temp1 = temp1 -> next ; 
        }

        temp2 = temp1->next->next;
        delete temp1->next;
        temp1->next = temp2;
        iNodeCnt--;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : Reverse 
// Description : To Reverse the Linked List 
// Input : NULL
// Output : NULL
// Author : Arvind Motiram Kale 
// Date :  8 - February - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyLL<T>::Reverse()
{
    PNODES<T> Previous,Next,Current;

    Previous = NULL ;
    Next = NULL ;
    Current = First ; 

    while(Current != NULL )
    {
        Next = Current->next; 
        Current->next = Previous ; 
        Previous = Current ; 

        Current = Next ; 
    }

    First = Previous;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : SearchFirstOccurrence 
// Description : To find out the First Occurrence of Specified element from the Linked List 
// Input : Element whose Occurrence you want to find
// Output : NULL
// Author : Arvind Motiram Kale 
// Date :  8 - February - 2022 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
int SinglyLL<T>::SearchFirstOccurrence(T No)
{
    PNODES<T> temp = First ; 
    int iCnt= 0;
    int iPos = -1; 

    while(temp!=NULL)
    {
        iCnt++ ; 
        if(temp->data == No)
        {
            iPos = iCnt ;
            break;
        }
        temp = temp -> next ; 
    }

    return iPos;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : SearchLastOccurrence 
// Description : To find out the Last Occurrence of Specified element from the Linked List 
// Input : Element whose Occurrence you want to find
// Output : NULL
// Author : Arvind Motiram Kale 
// Date :  8 - February - 2022 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
int SinglyLL<T>::SearchLastOccurrence(T No)
{
    PNODES<T> temp = First ; 
    int iPos = 0 ; 
    int iCnt = 0 ; 
    while(temp != NULL )
    {
        iCnt++;
        if(temp->data == No)
        {
            iPos = iCnt ; 
        }
        temp = temp->next;
    }

    return iPos ; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method DEfinations of Singly Circular Linked List 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : SinglyCL(Constructor) 
// Description : To Initialize the Characteristics as well as allocate the Resources of Singly Circular Linked List class 
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 13 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
SinglyCL<T>::SinglyCL()
{
    iNodeCnt = 0 ; 
    First = NULL ; 
    Last = NULL ; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : SinglyCL(Destructor) 
// Description : To Deallocate the Resources attached with Singly Circular Linked List class 
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 13 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> 
SinglyCL<T>::~SinglyCL()
{
    delete First ; 
    delete Last ; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertFirst
// Description : To Insert the element at beginning of the Linked List  
// Input : Element that you want to Insert 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 13 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyCL<T> :: InsertFirst(T iNo) 
{
    PNODES<T> newn = new NODES<T> ; 
    newn -> data = iNo ; 
    newn -> next = NULL ; 

    if( (First == NULL) && (Last == NULL )) // Linked List is Empty 
    {
        First = Last = newn ;
        Last -> next = First ;  
        iNodeCnt++ ; 
    }
    else 
    {
        newn -> next = First  ;
        First = newn ; 
        Last -> next = First ;  
        iNodeCnt++ ; 
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertLast
// Description : To Insert the element at the end of the Linked List  
// Input : Element that you want to Insert 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 13 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyCL<T> :: InsertLast(T iNo) 
{
    PNODES<T> newn = new NODES<T> ; 
    newn -> data = iNo ;
    newn -> next = NULL ; 

    if(First==NULL && Last == NULL )
    {
        First = Last = newn ; 
        Last -> next = First ; 
        iNodeCnt++; 
    }
    else 
    {
        Last -> next = newn ; 
        Last = newn ; 
        Last -> next = First ; 
        iNodeCnt++ ;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertAtPos
// Description : To Insert the element at specified Position of the Linked List  
// Input : Element that you want to Insert as well as Position at which you want to Insert the Element
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 13 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyCL<T> :: InsertAtPos(T iNo,int iPos) 
{
    if(iPos < 1 || iPos > iNodeCnt + 1 ) 
    {
        cout<<"Invalid Position\n" ; 
    }
    
    if(iPos == 1 )
    {
        InsertFirst(iNo) ; 
    }
    else if(iPos == iNodeCnt+1 )
    {
        InsertLast(iNo) ; 
    }
    else 
    {
        PNODES<T> newn = new NODES<T> ; 
        newn -> data = iNo ; 
        newn -> next = NULL ; 

        PNODES<T> temp = First ; 
        for(int i = 1 ; i < iPos - 1 ; i++ )
        {
            temp = temp -> next ; 
        }
        
        newn -> next = temp -> next ; 
        temp -> next = newn ; 
        iNodeCnt++ ;
    }
    
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteFirst
// Description : To Delete an Element from the First Position of the Linked List  
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 13 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyCL<T>::DeleteFirst()
{
    if(First == NULL && Last == NULL ) // Linked List is empty 
    {
        return ; 
    }
    else if(First == Last) // Linked List contains 1 Node 
    {
        delete First ; 
        First = Last = NULL ; 
    }
    else 
    {
        PNODES<T> temp = First ; 
        First = First -> next  ; 
        delete temp ; 
        Last -> next = First ; 
    }
}

template<class T>
void SinglyCL<T>::DeleteLast()
{
    if(First == NULL && Last == NULL ) 
    {
        return ; 
    }
    else if(First == Last )
    {
        delete First ; 
        First = Last = NULL ; 
        iNodeCnt-- ; 
    }
    else 
    {
        PNODES<T> temp = First ; 

        while(temp -> next != Last )
        {
            temp = temp -> next ; 
        }

        Last = temp ; 
        delete temp->next ;
        Last -> next  = First ; 
        iNodeCnt-- ;  
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteAtPos
// Description : To Delete an Element from the specified Position of the Linked List  
// Input : Position from which you want to Delete the Element
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 13 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyCL<T>::DeleteAtPos(int iPos)
{
    if(iPos < 1 || iPos > iNodeCnt ) 
    {
        cout<<"Invalid Position\n" ; 
        return ; 
    }

    if(iPos == 1 )
    {
        DeleteFirst() ; 
    }
    else if(iPos == iNodeCnt) 
    {
        DeleteLast() ; 
    }
    else 
    {
        PNODES<T> temp1 = First ; 
        PNODES<T> temp2 = NULL ; 
        for(int i = 1 ; i < iPos -1 ; i++ )
        {
            temp1 = temp1 -> next ;
        }

        temp2 = temp1 -> next ; 
        temp1 -> next  = temp2 -> next ; 
        delete temp2 ; 

    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : Display
// Description : To Display the Linked List  
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 13 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void SinglyCL<T>::Display()
{
    PNODES<T> temp = First ; 

    cout<<"Elements of Singly Circular Linked List : \n" ; 

    do 
    {
        cout<<"|"<<temp->data<<"|->" ; 
        temp = temp -> next ; 
    }while(temp != Last -> next ); 
    cout<<"NULL\n" ; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method Definations of Doubly Linear Linked List 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DoublyLL
// Description : To Initialize the Characteristics and allocate the Resources of Doubly Linear Linked List 
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
DoublyLL<T>::DoublyLL()
{
    First = NULL ; 
    iNodeCnt = 0 ; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DoublyLL
// Description : To Initialize the Characteristics and allocate the Resources of Doubly Linear Linked List 
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
DoublyLL<T>::DoublyLL()
{
    delete First ; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertFirst
// Description : To Insert an Element at the beginning of Doubly Linear Linked List 
// Input : Element that you want to Insert at Beginning of Doubly Linear Linked List 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyLL<T>::InsertFirst(T iNo)
{
    PNODED<T> newn = new NODED<T>;  
    newn->data = iNo;
    newn->next = NULL ; 
    newn->prev = NULL ; 

    if(First == NULL )
    {
        First = newn;
        iNodeCnt++; 
    }
    else 
    {
        newn->next = First ; 
        First -> prev = newn; 
        First = newn ; 
        iNodeCnt++; 
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertLast
// Description : To Insert an Element at the end of Doubly Linear Linked List 
// Input : Element that you want to Insert at end of Doubly Linear Linked List 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyLL<T>::InsertLast(T iNo)
{
    PNODED<T> newn = new NODED<T>; 

    newn->data = iNo ; 
    newn->next = NULL;
    newn->prev = NULL; 

    if(First == NULL )
    {
        First = newn ; 
        iNodeCnt++; 
    }
    else 
    {
        PNODED<T> temp = First ; 
        while(temp -> next != NULL )
        {
            temp = temp -> next ; 
        }
        temp->next = newn; 
        newn->prev = temp ;
        iNodeCnt++; 
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertAtPos
// Description : To Insert an Element at Specified Position of Doubly Linear Linked List 
// Input : Element that you want to Insert at end of Doubly Linear Linked List 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyLL<T>::InsertAtPos(T iNo,int iPos)
{
    if( (iPos < 1 ) || (iPos > iNodeCnt + 1 ) )
    {
        cout<<"Invalid Position\n";
        return ; 
    }
    if(iPos == 1 )
    {
        InsertFirst(iNo);
    }
    else if(iPos == iNodeCnt + 1 )
    {
        InsertLast(iNo);
    }
    else 
    {
        PNODED<T> temp = First ; 
        PNODED<T> newn = new NODED<T> ; 
        newn->data = iNo; 
        newn->next = NULL;
        newn->prev=NULL;

        for(int iCnt = 1 ; iCnt < iPos - 1 ; iCnt++ )
        {
            temp =temp->next;
        }

        newn->next = temp ->next; 
        newn->prev = temp ; 
        temp->next = newn;
        iNodeCnt++;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteFirst
// Description : To Delete an Element at First Position of Doubly Linear Linked List 
// Input : NULL 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyLL<T>::DeleteFirst()
{
    if(First == NULL )
    {
        cout<<"Linked List is Empty\n";
        return ; 
    }
    else if(First ->next == NULL )
    {
        delete First ; 
        First = NULL ; 
        iNodeCnt--;
    }
    else 
    {
        First = First -> next ; 
        delete First -> prev ;
        First -> prev = NULL ;
        iNodeCnt--;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteLast
// Description : To Delete an Element at the end of Doubly Linear Linked List 
// Input : NULL 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyLL<T>::DeleteLast()
{
    if(First == NULL )
    {
        cout<<"Linked List is Empty\n";
        return ; 
    }
    else if(First -> next == NULL )
    {
        delete First ; 
        First = NULL ; 
        iNodeCnt--;
    }
    else 
    {
        PNODED<T> temp = First ; 

        while(temp->next->next != NULL )
        {
            temp = temp -> next ; 
        }

        delete temp->next ; 
        temp->next = NULL ; 
        iNodeCnt--;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteFirst
// Description : To Delete the Element at specified position of Doubly Linear Linked List 
// Input : NULL 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyLL<T>::DeleteAtPos(int iPos)
{
    if((iPos<1)||(iPos>iNodeCnt))
    {
        cout<<"Invalid Position\n";
        return;
    }

    if(iPos==1)
    {
        DeleteFirst();
    }
    else if(iPos == iNodeCnt)
    {
        DeleteLast();
    }
    else 
    {
        PNODED<T> temp1=First; 
        PNODED<T> temp2=NULL ; 

        for(int iCnt = 1 ; iCnt < iPos - 1; iCnt++ )
        {
            temp1 = temp1 -> next ; 
        }

        temp2 = temp1 -> next; 
        temp1 -> next = temp2 -> next ; 
        delete temp2 ; 
        iNodeCnt--;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : Display
// Description : To Display Doubly Linear Linked List 
// Input : NULL 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 3 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyLL<T>::Display()
{
    PNODED<T> temp = First ; 

    cout<<"Elements of Doubly Linear Linked List : \n";

    cout<<"NULL";
    while(temp != NULL )
    {
        cout<<"<=>|"<<temp->data<<"|"; 
        temp = temp->next ; 
    }

    cout<<"<=>NULL\n";
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method Defination Section of Doubly Circular Linked List 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DoublyCL 
// Description : To Initialize the Characteristics as well as allocate the Resources of Doubly Circular Linked List 
// Input : NULL 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 15 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
DoublyCL<T>::DoublyCL()
{
    First = NULL ;
    Last = NULL ; 
    iNodeCnt  = 0 ; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : ~DoublyCL 
// Description : To deallocate the Resources of Doubly Circular Linked List 
// Input : NULL 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 15 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
DoublyCL<T>::~DoublyCL()
{
    delete First ;
    delete Last ; 
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertFirst 
// Description : To Insert element at the beginning of Doubly Circular Linked List 
// Input : Element that you want to Insert 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 15 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyCL<T>::InsertFirst(T iNo) 
{
    PNODED<T> newn = new NODED<T>;
    newn->data=iNo;
    newn->prev=NULL;
    newn->next=NULL;

    if(((First)==NULL)&&((Last)==NULL))//i.e Linked LIst is Empty
    {
        (First)=(Last)=newn;
        iNodeCnt++;
    }
    else 
    {
        newn->next=First;
        (First)->prev=newn;
        (First)=newn;
        iNodeCnt++;
    }

    (First)->prev=(Last);
    (Last)->next=(First);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertLast 
// Description : To Insert element at the end of Doubly Circular Linked List 
// Input : Element that you want to Insert 
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 15 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyCL<T>::InsertLast(T iNo)
{
    PNODED<T> newn = new NODED<T> ;
    newn->data=iNo;
    newn->prev=NULL;
    newn->next=NULL;

    if(((First)==NULL) && ((Last)==NULL))
    {
        (First)=(Last)=newn;
        iNodeCnt++;
    }
    else 
    {
        newn->prev=(Last);
        (Last)->next=newn;
        (Last)=newn;
        iNodeCnt++;
    }
    (First)->prev=(Last);
    (Last)->next=(First);

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : Display 
// Description : To Display Doubly Circular Linked List 
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 15 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyCL<T>::Display()
{
    cout<<"Elements of Doubly Circular Linked List are : \n";
    do 
    {
        cout<<"|"<<First->data<<"|<=>" ; 
        First=First->next;
    }while(First!=Last->next);

    cout<<"\n";
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : InsertAtPos 
// Description : To Insert element at specified Position of Doubly Circular Linked List 
// Input : Element that you want to Insert and the Position at which you want to insert the Element
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 15 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyCL<T>::InsertAtPos(T iNo,int iPos)
{
    if(iPos<1 || iPos > iNodeCnt + 1 )
    {
        cout<<"Invalid Position..";
        return;
    }
    if(iPos==1)
    {
        InsertFirst(iNo);
    }
    else if(iPos == iNodeCnt + 1)
    {
        InsertLast(iNo);
    }
    else 
    {
        PNODED<T> temp = First;
        PNODED<T> newn = new NODED<T>;
        newn->data=iNo;
        newn->next=NULL;
        newn->prev=NULL;

        for(int iCnt = 1 ; iCnt < iPos - 1; iCnt++ )
        {
            temp = temp -> next ; 
        }
        newn->prev = temp ;
        newn->next = temp->next ;
        temp->next->prev=newn;
        temp->next=newn;
        iNodeCnt++;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fuction Name : DeleteFirst 
// Description : To Delete element from the First Position of Doubly Circular Linked List 
// Input : NULL
// Output : NULL 
// Author : Arvind Motiram Kale 
// Date : 15 - December - 2022 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void DoublyCL<T>::DeleteFirst()
{
    if(((First)==NULL)&&((Last)==NULL))
    {
        return;
    }
    else if((First)==(Last))
    {
        delete First;
        (First)=(Last)=NULL;
        iNodeCnt--;
    }
    else 
    {
        (First)=(First)->next;
        delete ((Last)->next);
        (First)->prev=(Last);
        (Last)->next=(First);
        iNodeCnt--;
    }
}

template<class T>
void DoublyCL<T>::DeleteLast()
{
    if(((First)==NULL)&&((Last)==NULL))
    {
        return ; 
    }
    else if((First)==(Last))
    {
        delete (First);
        (First)=(Last);
        iNodeCnt--;
    }
    else 
    {
        (Last)=(Last)->prev;
        delete ((Last)->next);

        (Last)->next=(First);
        (First)->prev=(Last);
        iNodeCnt--;
    }
}

template<class T>
void DoublyCL<T>::DeleteAtPos(int iPos )
{
    if(iPos < 1 || iPos > iNodeCnt )
    {
        cout<<"Invalid Position\n";
        return ; 
    }
    if(iPos ==1 )
    {
        DeleteFirst();
    }
    else if(iPos == iNodeCnt)
    {
        DeleteLast();
    }
    else 
    {
        PNODED<T> temp =  First ; 
        for(int iCnt = 1 ; iCnt < iPos - 1; iCnt++ )
        {
            temp = temp -> next ; 
        }
        temp->next = temp->next->next;
        delete (temp->next->prev);
        temp->next->prev = temp ; 
        iNodeCnt--;
    }

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method Definations of Generic Stack
template<class T>
Stack<T>::Stack()
{
    First = NULL;
    iNodeCnt = 0;
}

template<class T>
bool Stack<T>::isStackEmpty()
{
    if(First == NULL)
    {
        return true;
    }
    else 
    {
        return false;
    }
}

template<class T>
void Stack<T>::push(T iNo) // InsertFirst 
{
    PNODE<T> newn = new NODE<T>;
    newn->data = iNo;
    newn->next = NULL;

    if(First == NULL)
    {
        First = newn;
        iNodeCnt++;
    }
    else 
    {
        newn->next = First;
        First = newn ; 
        iNodeCnt++;
    }
    cout<<iNo<<" pushed into the stack\n";
}

template<class T>
T Stack<T>::pop()
{
    T iRet = 0 ; 
    if(First == NULL)
    {
        cout<<"Unable to pop Element as Stack is Empty\n";
        return -1;
    }
    else if(First->next == NULL)
    {
        iRet = First -> data ; 
        delete First ; 
        First = NULL;
        iNodeCnt--;
        return iRet; 
    }
    else 
    {
        PNODE<T> temp = First; 
        First = First -> next ;
        iRet = temp->data;
        delete temp ;
        iNodeCnt--;
        return iRet ;
    }
}

template<class T> 
void Stack<T>::Display()
{
    if(First == NULL )
    {
        cout<<"Stack is Empty\n";
    }
    else 
    {
        cout<<"Elements of Stack are : \n";
        PNODE<T> temp = First ; 
        while(temp!=NULL)
        {
            cout<<"|"<<temp->data<<"|->" ; 
            temp = temp -> next;
        }
        cout<<"NULL\n";
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method Defination of Generic Queue 
template <class T>
Queue<T> :: Queue()
{
    First = NULL ; 
    iCount = 0 ; 
}

template <class T>
bool Queue<T> :: IsQueueEmpty()
{
    if(iCount == 0 )
    {
        return true ; 
    }
    else 
    
    {
        return false ; 
    }
}

template <class T>
void Queue<T> :: EnQueue(T no )  // InsertLast 
{
    PNODEQ<T> newn = new NODEQ<T> ; 

    newn -> data = no ; 
    newn -> next = NULL ; 

    if(First == NULL)
    {
        First = newn ; 
    }
    else 
    {
        PNODEQ<T> temp = First ; 

        while(temp -> next != NULL )
        {
            temp = temp-> next ; 
        }

        temp -> next = newn ; 
    }
    iCount++ ; 
}

template <class T>
T Queue<T> :: DeQueue() // DeleteFirst 
{
    if(First == NULL )
    {
        cout<<"Unable to Remove the element as Queue is Empty"<<"\n" ; 
        return (T)-1 ; 
    }

    else 
    {
        T Value = First->data ; 
        PNODEQ<T> temp = First ; 

        First = First -> next ; 
        delete temp ; 

        iCount-- ; 
        return Value ; 
    }
    
}

template <class T>
void Queue<T> :: Display()
{
    if(First == NULL )
    {
        cout<<"Queue is Empty"<<"\n" ; 
    }
    else 
    {
        cout<<"Elements of Queue are : "<<"\n" ; 

        PNODEQ<T> temp = First ; 

        while(temp != NULL )
        {
            cout<<"|"<<temp->data<<"|-> " ; 
            temp = temp -> next ; 
        }
        cout<<"NULL"<<"\n" ; 
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Main Function Section 
int main()
{
    cout<<"Welcome to Customized Standard Template Library Appliation\n";

    cout<<"This Application contains Implementation of all the Data Structures including both Linear as well as Non-Linear Data Structure in Generic Fashion\n";

    return 0 ; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////